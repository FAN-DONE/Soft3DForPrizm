#include <fxcg/display.h>
#include <fxcg/file.h>
#include <fxcg/keyboard.h>
#include <fxcg/system.h>
#include <fxcg/misc.h>
#include <fxcg/app.h>
#include <fxcg/serial.h>
#include <fxcg/rtc.h>
#include <fxcg/heap.h>

/*显示部分*/
color_t* VRAM_base;
#define LCD_GRAM 0x202
#define LCD_BASE 0xB4000000
#define SYNCO() __asm__ volatile("SYNCO\n\t":::"memory");
#define MSTPCR0_2	(volatile unsigned*)0xA4150030
#define DMA0_DMAOR	(volatile unsigned short*)0xFE008060
#define DMA0_SAR_0	(volatile unsigned*)0xFE008020
#define DMA0_DAR_0	(volatile unsigned*)0xFE008024
#define DMA0_TCR_0	(volatile unsigned*)0xFE008028
#define DMA0_CHCR_0	(volatile unsigned*)0xFE00802C

static inline void fxcg_PutDisplayWait(void);//DMA传输等待
static inline void fxcg_PutDisplay(void);//DMA传输
static inline void fxcg_PutDisplayEX(void);//DMA片传输

static inline void fxcg_PutDisplayWait(void){
	while(1){
		if((*DMA0_DMAOR)&4)
			break;
		if((*DMA0_CHCR_0)&2)
			break;}
	SYNCO();
	*DMA0_CHCR_0&=~1;
	*DMA0_DMAOR=0;
}
static inline void fxcg_PutDisplay(void){
	Bdisp_WriteDDRegister3_bit7(1);
	Bdisp_DefineDMARange(6,389,0,215);
	Bdisp_DDRegisterSelect(LCD_GRAM);
	*MSTPCR0_2&=~(1<<21);
	*DMA0_CHCR_0&=~1;
	*DMA0_DMAOR=0;
	*DMA0_SAR_0=((unsigned)VRAM_base)&0x1FFFFFFF;
	*DMA0_DAR_0=LCD_BASE&0x1FFFFFFF;
	*DMA0_TCR_0=5184;
	*DMA0_CHCR_0=0x00101401;
	*DMA0_DMAOR|=1;
	*DMA0_DMAOR&=~6;
}
static inline void fxcg_PutDisplayEX(unsigned y0,unsigned y1)
{
	Bdisp_WriteDDRegister3_bit7(1);
	Bdisp_DefineDMARange(6,389,y0,y1);
	Bdisp_DDRegisterSelect(LCD_GRAM);
	*MSTPCR0_2&=~(1<<21);
	*DMA0_CHCR_0&=~1;
	*DMA0_DMAOR=0;
	*DMA0_SAR_0=((unsigned)VRAM_base+(y0*384*2))&0x1FFFFFFF;
	*DMA0_DAR_0=LCD_BASE&0x1FFFFFFF;
	*DMA0_TCR_0=384*(y1-y0+1)/16;
	*DMA0_CHCR_0=0x00101401;
	*DMA0_DMAOR|=1;
	*DMA0_DMAOR&=~6;
}

/*数学部分*/
#define fxcg_abs(n) (n<0?-n:n)
#define INT_MAX 2147483647
#define INT_MIN -2147483648

#define FIX_SHIFT 15
#define MOD(x, y) ((x)<0 ? (y)+(x)%(y) : (x)%(y))
#define FIX(x) ((x)<<FIX_SHIFT)
#define UNFIX(x) ((x)>>FIX_SHIFT)
typedef int fix;
static inline fix ftofix(float f);
static inline float fixtof(fix f);
static inline fix fdiv(fix x, fix y);
static inline fix fmul(fix x, fix y);
static inline fix fsin(fix a);
static inline fix fcos(fix a);
static inline fix ftan(fix a);

static inline fix ftofix(float f) {
	return ((int)(f*32768));
	//return (int)(f*65536+0.5f);
}
static inline float fixtof(fix f) {
	return ((float)f)/(32768);
	//return ((float)f)/(65536.0f);
}
static inline fix fdiv(fix x, fix y) {
	if (y==0) return x;
	if (y>(1<<(2*FIX_SHIFT-2))) return x/(y>>FIX_SHIFT);
	return fmul(x, ((1<<(2*FIX_SHIFT))/y));
}
static inline fix fmul(fix x, fix y) {
	int d1, d2, e1, e2;
	e1 = x >> FIX_SHIFT;
	e2 = y >> FIX_SHIFT;
	d1 = x & (0xFFFFFFFF>>(32-FIX_SHIFT));
	d2 = y & (0xFFFFFFFF>>(32-FIX_SHIFT));
	return ((e1*e2)<<FIX_SHIFT) + e1*d2 + e2*d1 + ((d1*d2)>>FIX_SHIFT);
}

static inline void swapFix(fix* a, fix* b) {
	fix temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
int sqrtI2I( int v ){
    unsigned int t, q, b, r;
    r = v;           // r = v - x2
    b = 0x40000000;  // a2
    q = 0;           // 2ax
    while( b > 0 )
    {
        t = q + b;   // t = 2ax + a2
        q >>= 1;     // if a' = a/2, then q' = q/2
        if( r >= t ) // if (v - x2) >= 2ax + a2
        {
            r -= t;  // r' = (v - x2) - (2ax + a2)
            q += b;  // if x' = (x + a) then ax' = ax + a2, thus q' = q' + b
        }
        b >>= 2;     // if a' = a/2, then b' = b / 4
    }
    return q;
}
fix sqrtI2F( int v ){
    unsigned int t, q, b, r;
    if( !v ) return 0;
    r = v;
    b = 0x40000000;
    q = 0;
    while( b > 0 )
    {
        t = q + b;
        if( r >= t )
        {
            r -= t;
            q = t + b; // equivalent to q += 2*b
        }
        r <<= 1;
        b >>= 1;
    }
    if( r >= q ) ++q;
    return (q>>1);
}
fix sqrtF2F ( fix x ){
    unsigned int t, q, b, r;
    r = x;
    b = 0x20000000;
    q = 0;
    while( b > 0x40 )
    {
        t = q + b;
        if( r >= t )
        {
            r -= t;
            q = t + b;
        }
        r <<= 1;
        b >>= 1;
    }
    q >>= 8;
    return q;
}

static const int precalc_sin[901] = {
	0,			1874032,	3748058,	5622073,	7496071,	9370046,	11243993,
	13117905,	14991777,	16865604,	18739378,	20613096,	22486752,	24360338,
	26233852,	28107284,	29980632,	31853888,	33727044,	35600100,	37473048,
	39345884,	41218596,	43091184,	44963640,	46835960,	48708136,	50580168,
	52452040,	54323756,	56195304,	58066684,	59937884,	61808904,	63679732,
	65550372,	67420808,	69291040,	71161056,	73030864,	74900440,	76769800,
	78638912,	80507792,	82376432,	84244816,	86112936,	87980800,	89848400,
	91715720,	93582768,	95449528,	97315992,	99182160,	101048032,	102913592,
	104778840,	106643768,	108508376,	110372648,	112236584,	114100176,	115963424,
	117826320,	119688856,	121551024,	123412824,	125274248,	127135296,	128995952,
	130856208,	132716072,	134575536,	136434592,	138293216,	140151424,	142009216,
	143866576,	145723488,	147579952,	149435984,	151291552,	153146656,	155001296,
	156855456,	158709152,	160562352,	162415072,	164267296,	166119008,	167970224,
	169820928,	171671120,	173520784,	175369920,	177218512,	179066576,	180914096,
	182761056,	184607472,	186453312,	188298592,	190143296,	191987424,	193830960,
	195673904,	197516256,	199358016,	201199152,	203039680,	204879600,	206718880,
	208557552,	210395568,	212232960,	214069696,	215905776,	217741200,	219575968,
	221410064,	223243472,	225076224,	226908272,	228739632,	230570304,	232400272,
	234229520,	236058064,	237885888,	239712992,	241539360,	243364992,	245189872,
	247014032,	248837424,	250660048,	252481920,	254303024,	256123344,	257942896,
	259761664,	261579632,	263396800,	265213168,	267028736,	268843488,	270657408,
	272470528,	274282784,	276094240,	277904832,	279714592,	281523488,	283331520,
	285138720,	286945024,	288750464,	290555008,	292358688,	294161472,	295963360,
	297764352,	299564416,	301363584,	303161824,	304959168,	306755552,	308551008,
	310345536,	312139104,	313931712,	315723392,	317514112,	319303840,	321092608,
	322880384,	324667200,	326453024,	328237824,	330021664,	331804480,	333586272,
	335367072,	337146848,	338925568,	340703296,	342479936,	344255584,	346030144,
	347803680,	349576160,	351347552,	353117888,	354887136,	356655296,	358422400,
	360188384,	361953280,	363717088,	365479744,	367241344,	369001792,	370761120,
	372519328,	374276384,	376032320,	377787104,	379540736,	381293184,	383044512,
	384794656,	386543616,	388291424,	390038048,	391783456,	393527680,	395270720,
	397012544,	398753184,	400492576,	402230752,	403967712,	405703456,	407437952,
	409171200,	410903200,	412633952,	414363456,	416091680,	417818656,	419544352,
	421268768,	422991904,	424713760,	426434304,	428153568,	429871488,	431588128,
	433303456,	435017472,	436730144,	438441504,	440151520,	441860192,	443567488,
	445273472,	446978112,	448681344,	450383232,	452083776,	453782912,	455480672,
	457177024,	458872000,	460565600,	462257760,	463948544,	465637888,	467325824,
	469012352,	470697440,	472381088,	474063296,	475744064,	477423392,	479101248,
	480777664,	482452608,	484126080,	485798080,	487468576,	489137632,	490805152,
	492471200,	494135744,	495798784,	497460320,	499120352,	500778848,	502435808,
	504091264,	505745152,	507397536,	509048352,	510697600,	512345312,	513991456,
	515636064,	517279072,	518920512,	520560352,	522198624,	523835328,	525470400,
	527103904,	528735776,	530366048,	531994688,	533621728,	535247136,	536870912,
	538493056,	540113536,	541732416,	543349632,	544965184,	546579072,	548191296,
	549801856,	551410752,	553017920,	554623424,	556227264,	557829376,	559429824,
	561028544,	562625600,	564220864,	565814464,	567406336,	568996480,	570584896,
	572171520,	573756480,	575339648,	576921088,	578500736,	580078656,	581654784,
	583229120,	584801728,	586372544,	587941504,	589508736,	591074176,	592637824,
	594199680,	595759680,	597317888,	598874240,	600428800,	601981568,	603532416,
	605081472,	606628672,	608174080,	609717568,	611259264,	612799040,	614336960,
	615873024,	617407168,	618939456,	620469888,	621998400,	623525056,	625049792,
	626572608,	628093504,	629612544,	631129600,	632644800,	634158016,	635669312,
	637178688,	638686080,	640191616,	641695104,	643196672,	644696320,	646193984,
	647689664,	649183360,	650675072,	652164864,	653652608,	655138368,	656622144,
	658103936,	659583680,	661061504,	662537216,	664010944,	665482688,	666952320,
	668420032,	669885632,	671349184,	672810688,	674270208,	675727616,	677182976,
	678636288,	680087552,	681536704,	682983808,	684428800,	685871744,	687312576,
	688751296,	690187968,	691622464,	693054912,	694485248,	695913472,	697339520,
	698763520,	700185344,	701605056,	703022592,	704438016,	705851264,	707262400,
	708671424,	710078208,	711482880,	712885312,	714285632,	715683776,	717079744,
	718473536,	719865088,	721254464,	722641664,	724026688,	725409472,	726790016,
	728168384,	729544576,	730918464,	732290176,	733659648,	735026880,	736391872,
	737754624,	739115072,	740473344,	741829312,	743183104,	744534528,	745883776,
	747230656,	748575360,	749917696,	751257792,	752595584,	753931072,	755264320,
	756595200,	757923840,	759250112,	760574080,	761895808,	763215104,	764532160,
	765846848,	767159168,	768469248,	769776896,	771082240,	772385216,	773685888,
	774984128,	776280064,	777573632,	778864832,	780153600,	781440064,	782724096,
	784005760,	785285056,	786561920,	787836416,	789108544,	790378240,	791645504,
	792910400,	794172864,	795432896,	796690496,	797945664,	799198464,	800448768,
	801696640,	802942080,	804185088,	805425600,	806663744,	807899328,	809132544,
	810363264,	811591488,	812817280,	814040576,	815261376,	816479680,	817695552,
	818908864,	820119744,	821328128,	822533952,	823737280,	824938176,	826136512,
	827332288,	828525568,	829716352,	830904576,	832090304,	833273472,	834454144,
	835632192,	836807744,	837980800,	839151232,	840319104,	841484416,	842647232,
	843807424,	844965056,	846120128,	847272576,	848422464,	849569792,	850714496,
	851856640,	852996224,	854133120,	855267456,	856399232,	857528320,	858654848,
	859778752,	860900032,	862018688,	863134720,	864248128,	865358912,	866467008,
	867572544,	868675392,	869775616,	870873152,	871968064,	873060288,	874149888,
	875236800,	876321088,	877402624,	878481600,	879557824,	880631360,	881702272,
	882770432,	883835968,	884898752,	885958848,	887016320,	888070976,	889123008,
	890172288,	891218880,	892262784,	893303936,	894342400,	895378112,	896411072,
	897441344,	898468864,	899493632,	900515648,	901534976,	902551488,	903565312,
	904576384,	905584640,	906590208,	907592960,	908593024,	909590208,	910584704,
	911576384,	912565312,	913551488,	914534848,	915515392,	916493184,	917468160,
	918440384,	919409792,	920376384,	921340160,	922301184,	923259328,	924214720,
	925167296,	926116992,	927063936,	928008000,	928949248,	929887680,	930823296,
	931756032,	932686016,	933613056,	934537344,	935458688,	936377280,	937292928,
	938205760,	939115776,	940022848,	940927104,	941828544,	942727040,	943622720,
	944515456,	945405376,	946292352,	947176512,	948057728,	948936128,	949811584,
	950684160,	951553856,	952420608,	953284480,	954145472,	955003584,	955858752,
	956710976,	957560320,	958406720,	959250240,	960090816,	960928448,	961763200,
	962594944,	963423808,	964249792,	965072768,	965892800,	966709888,	967524096,
	968335296,	969143552,	969948864,	970751232,	971550656,	972347072,	973140608,
	973931072,	974718656,	975503232,	976284864,	977063488,	977839104,	978611840,
	979381504,	980148224,	980911936,	981672704,	982430464,	983185216,	983936960,
	984685760,	985431552,	986174272,	986914048,	987650816,	988384576,	989115328,
	989843008,	990567744,	991289408,	992008064,	992723776,	993436352,	994145984,
	994852544,	995556096,	996256576,	996954048,	997648512,	998339904,	999028288,
	999713600,	1000395840,	1001075072,	1001751232,	1002424320,	1003094400,	1003761408,
	1004425408,	1005086272,	1005744128,	1006398848,	1007050560,	1007699200,	1008344768,
	1008987264,	1009626688,	1010263040,	1010896320,	1011526464,	1012153600,	1012777600,
	1013398528,	1014016384,	1014631168,	1015242816,	1015851392,	1016456896,	1017059264,
	1017658560,	1018254784,	1018847872,	1019437824,	1020024704,	1020608512,	1021189184,
	1021766720,	1022341120,	1022912448,	1023480704,	1024045760,	1024607744,	1025166592,
	1025722304,	1026274944,	1026824384,	1027370752,	1027913984,	1028454080,	1028991040,
	1029524864,	1030055552,	1030583104,	1031107520,	1031628736,	1032146880,	1032661888,
	1033173696,	1033682368,	1034187904,	1034690304,	1035189568,	1035685632,	1036178560,
	1036668352,	1037154944,	1037638400,	1038118720,	1038595840,	1039069824,	1039540608,
	1040008256,	1040472704,	1040934016,	1041392128,	1041847104,	1042298880,	1042747520,
	1043192896,	1043635200,	1044074240,	1044510144,	1044942848,	1045372416,	1045798720,
	1046221888,	1046641856,	1047058624,	1047472256,	1047882624,	1048289856,	1048693888,
	1049094720,	1049492352,	1049886784,	1050278016,	1050666048,	1051050880,	1051432512,
	1051810944,	1052186112,	1052558144,	1052926976,	1053292608,	1053654976,	1054014144,
	1054370112,	1054722880,	1055072448,	1055418816,	1055761920,	1056101824,	1056438528,
	1056771968,	1057102272,	1057429248,	1057753088,	1058073664,	1058391040,	1058705152,
	1059016128,	1059323776,	1059628288,	1059929472,	1060227520,	1060522304,	1060813824,
	1061102144,	1061387200,	1061669056,	1061947712,	1062223104,	1062495232,	1062764160,
	1063029824,	1063292224,	1063551424,	1063807424,	1064060096,	1064309568,	1064555840,
	1064798784,	1065038528,	1065275072,	1065508288,	1065738304,	1065965056,	1066188608,
	1066408896,	1066625856,	1066839680,	1067050176,	1067257472,	1067461440,	1067662208,
	1067859776,	1068054016,	1068245056,	1068432768,	1068617280,	1068798528,	1068976512,
	1069151232,	1069322752,	1069490944,	1069655936,	1069817600,	1069976064,	1070131264,
	1070283200,	1070431808,	1070577216,	1070719360,	1070858240,	1070993856,	1071126272,
	1071255360,	1071381184,	1071503744,	1071623040,	1071739072,	1071851840,	1071961344,
	1072067584,	1072170560,	1072270272,	1072366720,	1072459904,	1072549824,	1072636480,
	1072719872,	1072800000,	1072876800,	1072950400,	1073020672,	1073087744,	1073151488,
	1073211968,	1073269248,	1073323200,	1073373888,	1073421312,	1073465472,	1073506304,
	1073543936,	1073578304,	1073609344,	1073637184,	1073661696,	1073682944,	1073700928,
	1073715648,	1073727104,	1073735296,	1073740160,	1073741824	};

static inline fix fsin(fix a) {
	int v;
	if(a<0) v = 3600+UNFIX(a*10)%3600;
	else v = UNFIX(a*10)%3600;
	if (v<=900) return precalc_sin[v]>>(30-FIX_SHIFT);
	if (v<=1800) return precalc_sin[1800-v]>>(30-FIX_SHIFT);
	if (v<=2700) return -(precalc_sin[v-1800]>>(30-FIX_SHIFT));
	return -(precalc_sin[3600-v]>>(30-FIX_SHIFT));
}
static inline fix fcos(fix a) {
	return fsin(FIX(90)-a);
}
static inline fix ftan(fix a) {
	return fdiv(fsin(a), fcos(a));
}

static inline void fxcg_swap(int &a,int &b);
static inline float fxcg_sqrt(float number);
static inline unsigned int fxcg_isqrt( unsigned int op );
static inline float fxcg_pow(float x, int n);
static inline int fxcg_ipow(int base, int exp);

static inline void fxcg_swap(int &a, int &b)
{int tmp = a;a = b;b = tmp;}
typedef struct{int x;int y;}Vec2i;
typedef struct{int x;int y;int z;}Vec3i;
typedef struct{float x;float y;}Vec2f;
typedef struct{float x;float y;float z;}Vec3f;
static inline void fxcg_Vec2iswap(Vec2i &ap,Vec2i &bp);

static inline void fxcg_Vec2iswap(Vec2i &ap,Vec2i &bp)
{Vec2i tmp = ap; ap = bp; bp = tmp;}
static inline void fxcg_Vec2fswap(Vec2f &ap,Vec2f &bp){
Vec2f tmp=ap;ap=bp;bp=tmp;}
static inline void fxcg_Vec3iswap(Vec3i& ap, Vec3i& bp) {
	Vec3i tmp = ap; ap = bp; bp = tmp;
}
static inline Vec3i ftofix3(Vec3f f) {
	Vec3i a;
	a.x = ftofix(f.x), a.y = ftofix(f.y),a.z=ftofix(f.z);
	return a;
}
static inline float fxcg_sqrt(float number){
	int i;
	float x2, y;
	const float threehalfs = 1.5F;

	x2 = number * 0.5F;
	y = number;
	i = *(int*)&y;
	i = 0x5f375a86 - (i >> 1);
	y = *(float*)&i;
	y = y * (threehalfs - (x2 * y * y));
	y = y * (threehalfs - (x2 * y * y));
	y = y * (threehalfs - (x2 * y * y));
	return number * y;
}
static inline float InvSqrt(float x){
    float xhalf = 0.5f * x;
    int i = *(int *)&x;
    i = 0x5f3759df - (i>>1);
    x = *(float *)&i;
    x = x * (1.5f - xhalf * x * x);
    return x;
}
static inline unsigned int fxcg_isqrt( unsigned int op ){
    unsigned int res = 0;
    unsigned int one = 1 << 30;
    while (one > op) one >>= 2;
    while (one != 0){
        if (op >= res + one){
            op -= res + one;
            res += one << 1;
        }
        res >>= 1;
        one >>= 2;
    }
    if (op > res) res++;
    return res;
}
static inline float fxcg_pow(float x, int n) {
        if(n == 0)
            return 1;
        float half = fxcg_pow(x, n/2);
        if(n%2 == 0)
            return half*half;
        else if(n > 0)
            return half*half*x;
        else 
            return half*half*(1/x);
}
static inline int fxcg_ipow(int base, int exp){
  int result = 1;
  while (exp) {
    if (exp & 1) result *= base;
    exp >>= 1;
    base *= base;
  }
  return result;
}
static inline Vec3i crossProduct(Vec3i a, Vec3i b) {
	Vec3i tmp;
	tmp.x = fmul(a.y, b.z) - fmul(a.z, b.y);
	tmp.y = fmul(a.z, b.x) - fmul(a.x, b.z);
	tmp.z = fmul(a.x, b.y) - fmul(a.y, b.x);
	return tmp;

}
static inline fix dotProduct(Vec3i a,Vec3i b) {
	fix product = fmul(a.x, b.x) + fmul(a.y, b.y) + fmul(a.z, b.z);
	return product;
}
static inline void normalizeVec3i(Vec3i* vertex) {
	Vec3i tmp;
	tmp.x = fmul(vertex->x, vertex->x);
	tmp.y = fmul(vertex->y, vertex->y);
	tmp.z = fmul(vertex->z, vertex->z);
	fix d = sqrtF2F(tmp.x + tmp.y + tmp.z);
	if (d == 0)
		d = (1 << 15);
	vertex->x = fdiv(vertex->x, d);
	vertex->y = fdiv(vertex->y, d);
	vertex->z = fdiv(vertex->z, d);
}

/*字符串部分*/
#define fxcg_isdigit(c) ((c) >= '0' && (c) <= '9')
unsigned int fxcg_strlen(const char *str);
float fxcg_atof(const char* str);
int fxcg_atoi(const char *str);
static inline void *fxcg_memccpy(void *dest, const void *src, int c, size_t num);
static inline void *fxcg_memset(void *dest, int c, unsigned int n);
char*fxcg_itoa(int num,char*str,int radix);

char *fxcg_itoa(int num,char *str,int radix) 
{  
	char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; 
	unsigned unum; 
	int i=0,j,k; 
	if(radix==10&&num<0)  
	{ 
		unum=(unsigned)-num; 
		str[i++]='-'; 
	} 
	else unum=(unsigned)num;
	do  
	{ 
		str[i++]=index[unum%(unsigned)radix]; 
		unum/=radix; 
	}while(unum); 
	str[i]='\0'; 
	if(str[0]=='-') k=1; 
	else k=0; 
	char temp; 
	for(j=k;j<=(i-k-1)/2.0;j++) 
	{ 
		temp=str[j]; 
		str[j]=str[i-j-1]; 
		str[i-j-1]=temp; 
	} 
	return str; 
}
unsigned int fxcg_strlen(const char *str) { 
	const char *s; for (s = str; *s; ++s) {} return(s - str); 
}
float fxcg_atof(const char* str) {
	const char* p = str;
	int sign = 1;
	while (*p == ' ')++p;
	if (*p == '-')
	{sign = -1;++p;}
	else if (*p == '+')++p;
	int hasDot = 0, hasE = 0;
	float integerPart = .0f, decimalPart = .0f;
	for (; *p; ++p) {
		if (fxcg_isdigit(*p)) 
			integerPart = 10 * integerPart + *p - '0';
		else if (*p == '.') {
			hasDot = 1;
			p++;
			break;
		}
		else if (*p == 'e' || *p == 'E') {
			hasE = 1;
			p++;
			break;
		}
		else 
			return integerPart;
	}
	int decimalDigits = 1;
	int exponential = 0;
	for (; *p; p++) {
		if (hasDot && fxcg_isdigit(*p))
			decimalPart += (*p - '0') / fxcg_pow(10, decimalDigits++);
		else if (hasDot && (*p == 'e' || *p == 'E')) {
			integerPart += decimalPart;
			decimalPart = 0.0;
			hasE = 1;
			++p;
			break;
		}
		else if (hasE && fxcg_isdigit(*p))
			exponential = 10 * exponential + *p - '0';
		else break;
	}
	if (hasE && hasDot)
		for (; *p; p++)
			if (fxcg_isdigit(*p))
				exponential = 10 * exponential + *p - '0';
	return sign * (integerPart * fxcg_pow(10, exponential) + decimalPart);

}
int fxcg_atoi(const char *str) { int num = 0; int sign = 1; const int len = fxcg_strlen(str); int i = 0; while (str[i] == ' ' && i < len) i++; if (str[i] == '+') i++; if (str[i] == '-') { sign = -1; i++; } for (; i < len; i++) { if (str[i] < '0' || str[i] > '9') break; if (num > INT_MAX / 10 || (num == INT_MAX / 10 && (str[i] - '0') > INT_MAX % 10)) { return sign == -1 ? INT_MIN : INT_MAX; } num = num * 10 + str[i] - '0'; } return num * sign; 
}
static inline void *fxcg_memccpy(void *dest, const void *src, int c, size_t num) {
    char* d = (char*)dest;
    char* s = (char*)src;
    while ((*d = *s) != (char)c && num > 0) {
        d++;
        s++;
        num--;
    }
    return num == 0 ? NULL : (void*)(++d);
}
static inline void *fxcg_memset(void *dest, int c, unsigned int n) {
    char* d = (char*)dest;
    while (n-- > 0) { *d++ = (char)c; }

    return dest;
}

/*按键部分*/
static inline int fxcg_key_down(int basic_keycode);

static inline int fxcg_key_down(int basic_keycode)
{
	const volatile unsigned short* keyboard_register = (unsigned short*)0xA44B0000;
	int row, col, word, bit;
	row = basic_keycode%10;
	col = basic_keycode/10-1;
	word = row>>1;
	bit = col + ((row&1)<<3);
	return (0 != (keyboard_register[word] & 1<<bit));
}

/*图形处理部分*/
static inline void fxcg_point(unsigned int x,unsigned int y,color_t color);
static inline void fxcg_point_s(unsigned int x,unsigned int y,color_t color);
static inline unsigned short fxcg_rgb_to_565(unsigned short r,unsigned short g,unsigned short b);
static inline void fxcg_lineVec(Vec2i p0,Vec2i p1,color_t color);
static inline void fxcg_line(int x0, int y0, int x1, int y1,color_t color);
static inline void fxcg_triangleVec(Vec2i t0, Vec2i t1, Vec2i t2,color_t color);
static inline void fxcg_triangle(int t0x, int t0y, int t1x,int t1y,int t2x,int t2y,color_t color);
static inline void fxcg_VRAMClear(color_t color);
static inline void FillVRAM(unsigned short color);

static inline void fxcg_point(unsigned int x,unsigned int y,color_t color)
{
	unsigned short*VRAM=VRAM_base;
	VRAM+=(y*LCD_WIDTH_PX)+x;
	*VRAM=color;
}
static inline void fxcg_point_s(unsigned int x,unsigned int y,color_t color)
{
	color_t*VRAM=VRAM_base;
	if(x>LCD_WIDTH_PX||y>LCD_HEIGHT_PX)
		return;
	VRAM+=(y*LCD_WIDTH_PX)+x;
	*VRAM=color;
}
static inline unsigned short fxcg_rgb_to_565(unsigned short r,unsigned short g,unsigned short b)
{
    return (unsigned short)((r << 8) & 0xF800) | ((g << 3) & 0x7E0) | ((b >> 3));
}
static inline void fxcg_lineVec(Vec2i p0,Vec2i p1,color_t color) {
    int steep = 0;
    if (fxcg_abs(p0.x - p1.x) < fxcg_abs(p0.y - p1.y)) {
        fxcg_swap(p0.x, p0.y);
        fxcg_swap(p1.x, p1.y);
        steep = 1;
    }
    if (p0.x > p1.x) {
       fxcg_swap(p0.x, p1.x);
       fxcg_swap(p0.y, p1.y);
    }
    int dx = p1.x - p0.x;
    int dy = p1.y - p0.y;
    int derror2 = ((fxcg_abs(dy))<<1);
    int error2 = 0;
    int y = p0.y;
    for (int x = p0.x; x <= p1.x; x++) {
        if (steep) {
            fxcg_point_s(y,x, color);
        }
        else {
            fxcg_point_s(x,y, color);
        }
        error2 += derror2;
        if (error2 > dx) {
            y += (p1.y > p0.y ? 1 : -1);
            error2 -= (dx<<1);
        }
    }
}
static inline void fxcg_line(int x0, int y0, int x1, int y1,color_t color) { 
    bool steep = false; 
    if (fxcg_abs(x0-x1)<fxcg_abs(y0-y1)) { 
        fxcg_swap(x0, y0); 
        fxcg_swap(x1, y1); 
        steep = true; 
    } 
    if (x0>x1) { 
        fxcg_swap(x0, x1); 
        fxcg_swap(y0, y1); 
    } 
    int dx = x1-x0; 
    int dy = y1-y0; 
    int derror2 = ((fxcg_abs(dy))<<1); 
    int error2 = 0; 
    int y = y0; 
    for (int x=x0; x<=x1; x++) { 
        if (steep) { 
            fxcg_point_s(y,x,color);
        } else { 
            fxcg_point_s(x, y, color); 
        } 
        error2 += derror2; 
        if (error2 > dx) { 
            y += (y1>y0?1:-1); 
            error2 -= (dx<<1); 
        } 
    } 
}
static inline void fxcg_triangleVec(Vec2i t0, Vec2i t1, Vec2i t2,color_t color) {
	if (t0.y == t1.y && t0.y == t2.y) return;
	if (t0.y > t1.y) fxcg_Vec2iswap(t0, t1);
	if (t0.y > t2.y) fxcg_Vec2iswap(t0, t2);
	if (t1.y > t2.y) fxcg_Vec2iswap(t1, t2);
	int total_height = t2.y - t0.y;
	for (int i = 0; i < total_height; i++) {
		int second_half = i > t1.y - t0.y || t1.y == t0.y;
		int segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;
		float alpha = (float)i / total_height;
		float beta =(float) (i - (second_half ? t1.y - t0.y : 0)) / segment_height;  
		int A = t0.x + (t2.x - t0.x) * alpha;
		int B = second_half ? t1.x + (t2.x - t1.x) * beta : t0.x + (t1.x - t0.x) * beta;
		if (A > B) fxcg_swap(A, B);
		for (int j = A; j <= B; j++) {
			fxcg_point_s(j, t0.y + i,color);
		}
	}
}
//定点数优化版本，相对于fxcg_triangleVec更快
static inline void fxcg_triangleVecFAST(Vec2i t0, Vec2i t1, Vec2i t2,color_t color) {
	if (t0.y == t1.y && t0.y == t2.y) return;
	if (t0.y > t1.y) fxcg_Vec2iswap(t0, t1);
	if (t0.y > t2.y) fxcg_Vec2iswap(t0, t2);
	if (t1.y > t2.y) fxcg_Vec2iswap(t1, t2);
	int total_height = t2.y - t0.y;
	for (int i = 0; i < total_height; i++) {
		int second_half = i > t1.y - t0.y || t1.y == t0.y;
		int segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;
		fix alpha = fdiv(FIX(i), FIX(total_height));
		fix beta = fdiv(FIX(i - (second_half ? t1.y - t0.y : 0)), FIX(segment_height));
		int A = UNFIX(FIX(t0.x) + fmul(FIX(t2.x - t0.x), alpha));
		int B = second_half ? UNFIX(FIX(t1.x)+fmul(FIX(t2.x-t1.x),beta)) : UNFIX(FIX(t0.x) + fmul(FIX(t1.x - t0.x), beta));
		if (A > B) fxcg_swap(A, B);
		for (int j = A; j <= B; j++) {
			fxcg_point_s(j, t0.y + i,color);
		}
	}
}
static inline Vec3i barycentric(Vec3i pts0,Vec3i pts1,Vec3i pts2, Vec3i p) {
	Vec3i temp0 = { FIX(pts2.x - pts0.x),FIX(pts1.x - pts0.x),FIX(pts0.x - p.x) };
	Vec3i temp1 = { FIX(pts2.y - pts0.y),FIX(pts1.y - pts0.y),FIX(pts0.y - p.y) };
	Vec3i u = crossProduct(temp0, temp1);
	Vec3i result = { -1,1,1 };
	if (fxcg_abs(u.y) < 1)
		return result;
	result.x = FIX(1) - fdiv((u.x + u.y), u.z);
	result.y = fdiv(u.y, u.z);
	result.z = fdiv(u.x, u.z);
	return result;
}
int*ZBUF=(int*)0x300000;//Prizm没有足够的内存支持Z缓冲
//Z插值并且采用重心坐标
static inline void fxcg_triangleZBUF(Vec3i t0, Vec3i t1, Vec3i t2, color_t color) {
	if (t0.y == t1.y && t0.y == t2.y) return;
	int t0x = t0.x, t1x = t1.x, t2x = t2.x;
	int t0y = t0.y, t1y = t1.y, t2y = t2.y;
	if (t0y > t1y) fxcg_swap(t0y, t1y);
	if (t0y > t2y) fxcg_swap(t0y, t2y);
	if (t1y > t2y) fxcg_swap(t1y, t2y);
	if (t0x > t1x) fxcg_swap(t0x, t1x);
	if (t0x > t2x) fxcg_swap(t0x, t2x);
	if (t1x > t2x) fxcg_swap(t1x, t2x);
	for (int i = t0x; i < t2x; i++) {
		for (int j = t0y; j < t2y; j++) {
			Vec3i P = { i,j,0 };
			Vec3i bc_screen = barycentric(t0, t1, t2, P);
			if (bc_screen.x < 0 || bc_screen.y < 0 || bc_screen.z < 0) continue;
			P.z += fmul(t0.z, bc_screen.x);
			P.z += fmul(t1.z, bc_screen.y);
			P.z += fmul(t2.z, bc_screen.z);
			//if (P.z < (zbuf[j + i * 384])) {
				fxcg_point_s(i,j,color|P.z);
			//	zbuf[j + i * width] = P.z;
			//}
		}
	}
}
//纹理三角形
static inline void fxcg_triangleVecT(Vec2i t0,Vec2i t1,Vec2i t2,Vec2i uv0,Vec2i uv1,Vec2i uv2,int width,color_t*color) {
//TODO
}
static inline void extractColor(color_t x, char *r, char *g, char *b) {
    *b = (x & 0x1F) << 1;
    *g = (x >> 5) & 0x2F;
    *r = ((x >> 11) & 0x1F) << 1;
}
typedef struct{
	fix r;
	fix g;
	fix b;
}Color3;
//漫反射光照
static inline void fxcg_triangleVecLight(Vec3i t0, Vec3i nor0, Vec3i t1, Vec3i nor1, Vec3i t2, Vec3i nor2, Vec3i lightpos,Vec3i objectcolor,Vec3i lightcolor) {
	if (t0.y == t1.y && t0.y == t2.y) return;
	int t0x = t0.x, t1x = t1.x, t2x = t2.x;
	int t0y = t0.y, t1y = t1.y, t2y = t2.y;
	if (t0y > t1y) fxcg_swap(t0y, t1y);
	if (t0y > t2y) fxcg_swap(t0y, t2y);
	if (t1y > t2y) fxcg_swap(t1y, t2y);
	if (t0x > t1x) fxcg_swap(t0x, t1x);
	if (t0x > t2x) fxcg_swap(t0x, t2x);
	if (t1x > t2x) fxcg_swap(t1x, t2x);
	for (int i = t0x; i < t2x; i++) {
		for (int j = t0y; j < t2y; j++) {
			Vec3i P = { i,j,0 };
			Vec3i bc_screen = barycentric(t0, t1, t2, P);
			if (bc_screen.x < 0 || bc_screen.y < 0 || bc_screen.z < 0) continue;
			P.z += fmul(t0.z, bc_screen.x);
			P.z += fmul(t1.z, bc_screen.y);
			P.z += fmul(t2.z, bc_screen.z);
			//if (P.z < (ZBUF[j + i * 384])) {
				Vec3i Pnor;
				Pnor.x = fmul(bc_screen.x, nor0.x + nor1.x + nor2.x);
				Pnor.y = fmul(bc_screen.y, nor0.y + nor1.y + nor2.y);
				Pnor.z = fmul(bc_screen.z, nor0.z + nor1.z + nor2.z);
				Vec3i lightDir;
				lightDir.x = lightpos.x - P.x;
				lightDir.y = lightpos.y - P.y;
				lightDir.z = lightpos.z - P.z;
				normalizeVec3i(&lightDir);
				normalizeVec3i(&Pnor);
				fix diff = fxcg_abs(dotProduct(Pnor, lightDir));
				Vec3i diffuse;
				diffuse.x = fmul(diff, objectcolor.x) * lightcolor.x >> 15;
				diffuse.x = diffuse.x * 255 >> 15;
				diffuse.y = fmul(diff, objectcolor.y) * lightcolor.y >> 15;
				diffuse.y = diffuse.y * 255 >> 15;
				diffuse.z = fmul(diff, objectcolor.z) * lightcolor.z >> 15;
				diffuse.z = diffuse.z * 255 >> 15;
				color_t endcolor=fxcg_rgb_to_565(diffuse.x,diffuse.y,diffuse.z);
				fxcg_point_s(i, j, endcolor);
				//ZBUF[j + i * 384] = P.z;
			//}
		}
	}
}
static inline void fxcg_VRAMClear(color_t color)
{
	unsigned int*VRAM32=(unsigned int*)VRAM_base;
	unsigned colorr=(unsigned)((color<<16) | color);
	for(unsigned int i=0;i<=41472;i++)
	       *(VRAM32++)=colorr;
}
static inline void FillVRAM(unsigned short color)
{
	int i, color32bits, *VRAM = (int*)GetVRAMAddress();
	color32bits = (color<<16) | color;
	for(i=LCD_WIDTH_PX*LCD_HEIGHT_PX/2 ; i ; i--)
		*(VRAM++) = color32bits;
}

/*闪存部分*/
//Search the whole flash, do not assume FS start at 0xA1000000 
//(already tried interval 0xA1000000 - 0xA1FFFFFF, but some parts of the file were outside of this interval)
#define FLASH_START 0xA0000000  
//page has 4 KB (I hope)
#define FLASH_PAGE_SIZE 4096
//8K pages
#define FLASH_PAGE_COUNT (4096*2)

//allocate 128 items for max 128 fragments of the file.
// 640 KB should to be enough for everyone ;-)
#define MAX_FRAGMENTS 128
//descriptor for 1 fragment
typedef struct
{
	short msOffset;//page index (0 ~ 8K)
	short msCount;//count of pages in this fragment
}FileMappingItem;
typedef struct
{
	FileMappingItem mTable[MAX_FRAGMENTS];//table of fragments
	int miItemCount;
	int miTotalLength;//length of the file
	int miCurrentLength;//currently returned length (by GetNextdata() )
	int miCurrentItem;//active fragment (to be returned by GetNextdata() )

}FileMapping;
//reset reading to start
static inline void fxcg_ResetData(FileMapping *pMap)
{
	pMap->miCurrentItem = 0;
	pMap->miCurrentLength = 0;
}
static inline void fxcg_ResetData(FileMapping *pMap);
static inline int fxcg_GetNextData(FileMapping *pMap,int *piLength,unsigned char **ppBuffer);
static inline int fxcg_CreateFileMapping(const unsigned short *pFileName,FileMapping *pMap);

//get pointer to next fragment of the file
static inline int fxcg_GetNextData(FileMapping *pMap,int *piLength,unsigned char **ppBuffer)
{
	unsigned char *pFlashFS = (unsigned char *)FLASH_START;
	FileMappingItem *pItem = &(pMap->mTable[pMap->miCurrentItem]);
	if(pMap->miCurrentItem >= pMap->miItemCount)
	{
		//eof ?
		*piLength = 0;
		return -1;
	}
	pMap->miCurrentItem++;
	*ppBuffer = pFlashFS + (((int)pItem->msOffset)*FLASH_PAGE_SIZE);
	*piLength = ((int)pItem->msCount)*FLASH_PAGE_SIZE;
    pMap->miCurrentLength += *piLength;
	if(pMap->miCurrentLength >  pMap->miTotalLength)
	{
		//last page is only partially used
		*piLength -= pMap->miCurrentLength - pMap->miTotalLength;
		pMap->miCurrentLength = pMap->miTotalLength;
	}
	return 0;
}

static inline int Xmemcmp(const char *p1,const char *p2,int len)
{
	while(len)
	{
		if(*p1 != *p2)
		{
			return 1;}
		p1++;p2++;len--;
	}
	return 0;
}
static inline int fxcg_CreateFileMapping(const unsigned short *pFileName,FileMapping *pMap)
{
	int iResult = 0;
	char cBuffer[FLASH_PAGE_SIZE];
	int hFile = Bfile_OpenFile_OS(pFileName,3,0);
	int iLength;
	char *pFlashFS = (char *)FLASH_START;

	pMap->miItemCount = 0;
	pMap->miTotalLength = 0;
	iLength = Bfile_ReadFile_OS(hFile,cBuffer,FLASH_PAGE_SIZE,-1);
	while(iLength > 0)
	{
		//do not optimize (= do not move these 2 variables before loop)!
		// fx-cg allocates pages for file in <random> order so page from the end of the file 
		//can have lower index than page from the beginning
		const char *pTgt = pFlashFS;
		int iPageIndx = 0;

		for(;iPageIndx < FLASH_PAGE_COUNT;iPageIndx++)
		{
			if(!Xmemcmp(pTgt,cBuffer,iLength))
			{
				break;
			}
			pTgt += FLASH_PAGE_SIZE;
		}
		if(iPageIndx == FLASH_PAGE_COUNT)
		{
			//page not found !
			iResult = -2;
			goto lbExit;
		}
		pMap->miItemCount ++;
		if(pMap->miItemCount >= MAX_FRAGMENTS)
		{
			//file too fragmented !
			iResult = -3;
			goto lbExit;
		}
		pMap->mTable[pMap->miItemCount-1].msOffset = (short)iPageIndx;
		pMap->mTable[pMap->miItemCount-1].msCount = 0;
		//assume fragment has more pages
		for(;;)
		{
			pMap->mTable[pMap->miItemCount-1].msCount++;
			pMap->miTotalLength += iLength;
			iPageIndx++;
			pTgt += FLASH_PAGE_SIZE;

			if(iLength < FLASH_PAGE_SIZE)
			{
				//this was the last page
				iResult = pMap->miTotalLength;
				goto lbExit;
			}
			iLength = Bfile_ReadFile_OS(hFile,cBuffer,FLASH_PAGE_SIZE,-1);
			if(iLength <= 0)
			{
				break;
			}
			if(Xmemcmp(pTgt,cBuffer,iLength))
			{
				break;
			}
		}
	}
	if(iLength < 0)
	{
		iResult = -1;
	}
	else
	{
		iResult = pMap->miTotalLength;
	}

lbExit:
	Bfile_CloseFile_OS(hFile);
	return iResult;

}

typedef struct
{
  unsigned short id, type;
  unsigned int fsize, dsize;
  unsigned int property;
  unsigned int address;
} file_type_t;

//随机数发生
static unsigned int lastrandom = 0x12345678;
void srand(unsigned int seed){
	lastrandom = seed;
}
int rand(void){
	lastrandom = 0x41C64E6D*lastrandom + 0x3039;
	return lastrandom >> 16;
}

//STATIC STACK 0x88160000-0x881DFFFF
//malloc 0x881E0000-0x881FFFFF 最大分配131060字节

static inline void fxcg_CopySprite(const color_t* data, int x, int y, int width, int height) {
    color_t *VRAM = (color_t*)GetVRAMAddress();
    VRAM += (384 * y) + x;

    for(int j = 0; j <height; j++) {
        for (int i = 0; i < width; i++) {
            *VRAM++ = *data++;
        }
        VRAM +=384 - width;
    }
}

#define MAX_FILENAME_SIZE 270 
#define MAX_NAME_SIZE 128
#define MAX_ITEMS_IN_DIR 200
#define MAX_ITEMS_IN_CLIPBOARD 75
typedef struct
{
  char filename[MAX_FILENAME_SIZE]; //全路径
  char name[MAX_FILENAME_SIZE]; //文件名
  int size; // 大小
  short action; 
  short isfolder;
} File;
int openfile(char*cpFilename){
	unsigned short spFilename[MAX_FILENAME_SIZE+1];
	Bfile_StrToName_ncpy(spFilename,cpFilename,MAX_FILENAME_SIZE+1);
	int ret=Bfile_OpenFile_OS(spFilename,3,0);//读写模式
	return ret;
}
int closeFile(int handle){
	Bfile_CloseFile_OS(handle);
	return 0;
}
int findFile(char*cpPath,File*ftFiles,int*iFilecount){
	unsigned short spPath[MAX_NAME_SIZE+1],spFoundFile[MAX_FILENAME_SIZE+1];
	int iFindhandle,itempcout=0;
	file_type_t ftFileinfo;
	Bfile_StrToName_ncpy(spPath,cpPath,MAX_FILENAME_SIZE+1);
	int ret=Bfile_FindFirst_NON_SMEM((const char*)spPath,&iFindhandle,(char*)spFoundFile,&ftFileinfo);
	if (ret<0){
		Bfile_FindClose(iFindhandle);
		return -1;
	}
	while (!ret){
		Bfile_NameToStr_ncpy(ftFiles[itempcout].name,spFoundFile,MAX_FILENAME_SIZE+1);
		//TODO:全路径
		ftFiles[itempcout].size=ftFileinfo.fsize;
		ftFiles[itempcout].isfolder=!ftFileinfo.fsize;
		itempcout++;
		if (itempcout==200){
			Bfile_FindClose(iFindhandle);
			return 0;
		}
		ret = Bfile_FindNext_NON_SMEM(iFindhandle, (char*)spFoundFile, (char*)&ftFileinfo);
	}
	Bfile_FindClose(iFindhandle);
	*iFilecount=itempcout;
	return 0;
}
//坐标系变换
static inline int tr3(Vec3f vertex, Vec3f normal, int angle, Vec3i* result,Vec3i* nor) {
	Vec3i tmp;
	fix z = ftofix(vertex.z);
	fix x = ftofix(vertex.x);
	fix y = ftofix(vertex.y);
	int an = FIX(angle);
	tmp.x = fmul(fcos(an), x) + fmul(fsin(an), z);
	tmp.y = y;
	tmp.z = fmul(fcos(an), z) - fmul(fsin(an), x);
	tmp.z = 65535 - tmp.z;
	tmp.x = fdiv(tmp.x, tmp.z);
	tmp.y = fdiv(tmp.y, tmp.z);
	tmp.x = UNFIX(tmp.x << 6) + 192;
	tmp.y = -UNFIX(tmp.y << 6) + 108;
	*result = tmp;
	*nor = ftofix3(normal);
	return 0;
}
static inline int tr3t(Vec3f vertex, Vec3f normal, Vec3f tran, int angle, Vec3i* result, Vec3i* nor) {
	Vec3i tmp;
	Vec3i ttran = ftofix3(tran);
	fix z = ftofix(vertex.z)+ttran.z;
	fix x = ftofix(vertex.x) + ttran.x;
	fix y = ftofix(vertex.y) + ttran.x;
	int an = FIX(angle);
	tmp.x = fmul(fcos(an), x) + fmul(fsin(an), z);
	tmp.y = y;
	tmp.z = fmul(fcos(an), z) - fmul(fsin(an), x);
	tmp.z = 65535 - tmp.z;
	tmp.x = fdiv(tmp.x, tmp.z);
	tmp.y = fdiv(tmp.y, tmp.z);
	tmp.x = UNFIX(tmp.x << 6) + 192;
	tmp.y = -UNFIX(tmp.y << 6) + 108;
	*result = tmp;
	*nor = ftofix3(normal);
	return 0;
}

